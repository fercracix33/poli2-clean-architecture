# Entity Design Patterns with Zod

Advanced Zod schema patterns and validation strategies for entity design, based on latest best practices from Context7.

---

## Core Principles

### 1. Pure Data Contracts Only

entities.ts files must contain ONLY:
- ✅ Zod schema definitions
- ✅ TypeScript type inference
- ✅ JSDoc comments for complex schemas
- ❌ NO business logic
- ❌ NO external dependencies (except Zod)
- ❌ NO functions (except type guards)

### 2. Database ↔ TypeScript Mapping

**Database convention**: `snake_case`
```sql
user_id UUID
created_at TIMESTAMPTZ
```

**TypeScript convention**: `camelCase`
```typescript
userId: string
createdAt: Date
```

**Zod handles the mapping**: Fields are defined in camelCase, they map to snake_case in database automatically via Supabase.

---

## Basic Schema Patterns

### Standard Entity Schema

```typescript
import { z } from 'zod';

export const EntitySchema = z.object({
  // UUID fields
  id: z.string().uuid(),
  userId: z.string().uuid(),
  organizationId: z.string().uuid(),

  // String fields with validation
  name: z.string()
    .min(2, "Nombre debe tener al menos 2 caracteres")
    .max(100, "Nombre no puede exceder 100 caracteres"),

  // Optional string
  description: z.string()
    .max(500, "Descripción no puede exceder 500 caracteres")
    .optional(),

  // Email validation
  email: z.string().email("Email inválido"),

  // URL validation
  avatarUrl: z.string().url("URL inválida").optional(),

  // Enum
  status: z.enum(['active', 'inactive', 'pending'], {
    errorMap: () => ({ message: "Estado inválido" })
  }),

  // Dates - ALWAYS use .coerce for DB dates
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});
```

**Why `.coerce.date()`?**
- Supabase returns dates as ISO 8601 strings
- `.coerce.date()` automatically converts string → Date
- Without `.coerce`, you'd get validation errors

---

## Derived Schemas

### Create Schema (Omit Auto-Generated Fields)

```typescript
export const EntityCreateSchema = EntitySchema.omit({
  id: true,           // Auto-generated by database
  createdAt: true,    // Auto-set by database
  updatedAt: true,    // Auto-set by database
});

export type EntityCreate = z.infer<typeof EntityCreateSchema>;
```

**What to omit**:
- `id`: Database generates UUIDs
- `createdAt`, `updatedAt`: Database sets timestamps
- Any other auto-generated fields

### Update Schema (Partial, Omit Immutable)

```typescript
export const EntityUpdateSchema = EntitySchema
  .omit({
    id: true,              // Never change ID
    userId: true,          // Immutable ownership
    organizationId: true,  // Immutable tenancy
    createdAt: true,       // Immutable creation time
    updatedAt: true,       // Auto-updated by database
  })
  .partial();  // All remaining fields optional

export type EntityUpdate = z.infer<typeof EntityUpdateSchema>;
```

**What to omit**:
- Immutable fields that should never change
- Auto-managed fields (timestamps)

**Why `.partial()`?**
- Allows partial updates (only changed fields)
- All fields become optional

### Query Schema (For List Endpoints)

```typescript
export const EntityQuerySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().positive().max(100).default(20),
  sortBy: z.enum(['createdAt', 'updatedAt', 'name']).default('createdAt'),
  order: z.enum(['asc', 'desc']).default('desc'),

  // Optional filters
  status: z.enum(['active', 'inactive', 'pending']).optional(),
  search: z.string().min(1).optional(),
});

export type EntityQuery = z.infer<typeof EntityQuerySchema>;
```

**Use `.coerce.number()`** for query params:
- Query params come as strings from URL
- `.coerce.number()` converts "20" → 20

---

## Advanced Validation Patterns

### Pattern 1: String with Regex

```typescript
const SlugSchema = z.string()
  .min(2, "Identificador debe tener al menos 2 caracteres")
  .max(50, "Identificador no puede exceder 50 caracteres")
  .regex(
    /^[a-z0-9\-_]+$/,
    "Solo letras minúsculas, números, guiones y guiones bajos"
  );
```

**Common regex patterns**:
- Slug: `/^[a-z0-9\-_]+$/`
- Alphanumeric: `/^[a-zA-Z0-9]+$/`
- Alphanumeric with spaces: `/^[a-zA-Z0-9\s\-_]+$/`

### Pattern 2: Custom Refinement

**Use `.refine()` for complex validations:**

```typescript
const PasswordSchema = z.string()
  .min(8, "Contraseña debe tener al menos 8 caracteres")
  .refine(
    (val) => /[A-Z]/.test(val),
    "Debe contener al menos una mayúscula"
  )
  .refine(
    (val) => /[a-z]/.test(val),
    "Debe contener al menos una minúscula"
  )
  .refine(
    (val) => /[0-9]/.test(val),
    "Debe contener al menos un número"
  );
```

**When to use `.refine()`**:
- Custom validation logic not covered by built-in validators
- Business rules (e.g., password strength)
- Cross-field validation (within the refinement function)

### Pattern 3: Conditional Validation with `.superRefine()`

**Use `.superRefine()` for multiple issues or complex logic:**

```typescript
const UniqueStringArraySchema = z.array(z.string()).superRefine((val, ctx) => {
  // Check length
  if (val.length > 10) {
    ctx.addIssue({
      code: z.ZodIssueCode.too_big,
      maximum: 10,
      type: "array",
      inclusive: true,
      message: "Máximo 10 elementos permitidos",
    });
  }

  // Check for duplicates
  if (val.length !== new Set(val).size) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: "No se permiten duplicados",
    });
  }
});
```

**`.superRefine()` vs `.refine()`**:
- `.refine()`: Single validation, returns boolean
- `.superRefine()`: Multiple issues, uses `ctx.addIssue()`

### Pattern 4: Chained Transformations

**Use `.transform()` to modify validated data:**

```typescript
const NormalizedEmailSchema = z.string()
  .email("Email inválido")
  .transform((val) => val.toLowerCase())
  .transform((val) => val.trim());
```

**Execution order**: Validate → Transform → Validate again (if chained)

```typescript
const StringToNumberSchema = z.string()
  .transform((val) => val.length)
  .refine((len) => len > 5, "String debe tener más de 5 caracteres");
```

**Use cases for `.transform()`**:
- Normalization (lowercase, trim)
- Type conversion (string → number)
- Data enrichment (adding computed fields)

### Pattern 5: Preprocessing with `.preprocess()`

**Use `.preprocess()` to transform BEFORE validation:**

```typescript
const CoercedIntSchema = z.preprocess(
  (val) => {
    if (typeof val === "string") {
      return Number.parseInt(val, 10);
    }
    return val;
  },
  z.number().int()
);
```

**`.preprocess()` vs `.transform()`**:
- `.preprocess()`: Transforms BEFORE validation
- `.transform()`: Transforms AFTER validation

**Use `.preprocess()` for**:
- Coercing types from external sources
- Cleaning malformed input
- Default value injection

### Pattern 6: Async Validation

**Use `.refine()` with async function:**

```typescript
const UniqueEmailSchema = z.string()
  .email("Email inválido")
  .refine(
    async (email) => {
      // Check if email exists in database
      const exists = await checkEmailExists(email);
      return !exists;
    },
    "Este email ya está registrado"
  );
```

**⚠️ CRITICAL**: Must use `.parseAsync()` when schema has async refinements:

```typescript
// ✅ Correct
const result = await UniqueEmailSchema.parseAsync("test@example.com");

// ❌ Wrong - will not work with async refinements
const result = UniqueEmailSchema.parse("test@example.com");
```

**When to use async validation**:
- Database uniqueness checks
- External API validation
- Rate-limited operations

### Pattern 7: Conditional Fields

**Use `.refine()` for conditional requirements:**

```typescript
const ConditionalSchema = z.object({
  type: z.enum(['email', 'sms']),
  emailAddress: z.string().email().optional(),
  phoneNumber: z.string().optional(),
}).refine(
  (data) => {
    if (data.type === 'email') {
      return !!data.emailAddress;
    }
    if (data.type === 'sms') {
      return !!data.phoneNumber;
    }
    return true;
  },
  {
    message: "Email requerido cuando tipo es 'email'",
    path: ["emailAddress"],
  }
);
```

**Error path**: Use `path` array to point error to specific field.

---

## Project-Specific Patterns

### Pattern: Multi-Tenant Entity

**All entities must include `organizationId` for multi-tenancy:**

```typescript
export const EntitySchema = z.object({
  id: z.string().uuid(),

  // Multi-tenant isolation
  organizationId: z.string().uuid(),

  // Ownership
  userId: z.string().uuid(),

  // ... other fields

  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});
```

**Why**:
- RLS policies use `organizationId` for data isolation
- Every feature must respect multi-tenancy
- Pattern is consistent across all entities

### Pattern: Invite Code Generation

**8-character alphanumeric codes:**

```typescript
export const InviteCodeSchema = z.string()
  .length(8, "Código debe tener exactamente 8 caracteres")
  .regex(/^[A-Z0-9]+$/, "Solo letras mayúsculas y números");
```

**Generation example (not in entities.ts)**:
```typescript
// In use case or service
const generateInviteCode = (): string => {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  return Array.from({ length: 8 }, () =>
    chars[Math.floor(Math.random() * chars.length)]
  ).join('');
};
```

### Pattern: Slug Generation

**URL-friendly identifiers:**

```typescript
export const SlugSchema = z.string()
  .min(2, "Identificador debe tener al menos 2 caracteres")
  .max(50, "Identificador no puede exceder 50 caracteres")
  .regex(/^[a-z0-9\-_]+$/, "Solo minúsculas, números, guiones y guiones bajos");
```

**Generation example (not in entities.ts)**:
```typescript
// In use case
const generateSlug = (name: string): string => {
  return name
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Remove accents
    .replace(/[^a-z0-9\s\-_]/g, '')  // Remove special chars
    .replace(/\s+/g, '-')             // Spaces to hyphens
    .replace(/-+/g, '-')              // Multiple hyphens to single
    .replace(/^-|-$/g, '');           // Trim hyphens
};
```

---

## Type Guards (Optional)

**Use type guards for runtime type checking:**

```typescript
export function isEntity(value: unknown): value is Entity {
  return EntitySchema.safeParse(value).success;
}

export function isEntityCreate(value: unknown): value is EntityCreate {
  return EntityCreateSchema.safeParse(value).success;
}
```

**When to use**:
- When dealing with `unknown` types
- Runtime validation before processing
- Defensive programming at boundaries

**Note**: Use sparingly, Zod `.parse()` is usually sufficient.

---

## Error Handling Patterns

### Pattern: Safe Parsing

**Use `.safeParse()` when you want to handle errors gracefully:**

```typescript
const result = EntitySchema.safeParse(unknownData);

if (result.success) {
  // TypeScript knows result.data is Entity
  const entity: Entity = result.data;
} else {
  // TypeScript knows result.error is ZodError
  console.error(result.error.issues);
}
```

**`.safeParse()` vs `.parse()`**:
- `.safeParse()`: Returns `{ success: boolean, data?, error? }`
- `.parse()`: Returns data or throws ZodError

### Pattern: Custom Error Messages

**Provide user-friendly Spanish messages:**

```typescript
const NameSchema = z.string()
  .min(2, "El nombre debe tener al menos 2 caracteres")
  .max(100, "El nombre no puede exceder 100 caracteres")
  .regex(
    /^[a-zA-ZáéíóúÁÉÍÓÚñÑ\s]+$/,
    "El nombre solo puede contener letras y espacios"
  );
```

**Error message guidelines**:
- Always in Spanish (project standard)
- Be specific about the requirement
- Use formal "usted" form
- Provide actionable guidance

### Pattern: Error Path for Nested Objects

```typescript
const FormSchema = z.object({
  user: z.object({
    email: z.string().email("Email inválido"),
    password: z.string().min(8),
  }),
  terms: z.boolean(),
}).refine(
  (data) => data.terms === true,
  {
    message: "Debe aceptar los términos y condiciones",
    path: ["terms"],  // Error points to specific field
  }
);
```

**Error path**: Use to point validation errors to specific nested fields in forms.

---

## Performance Considerations

### Use `.pipe()` for Chained Transformations

**Efficient chaining:**

```typescript
const OptimizedSchema = z.string()
  .pipe(z.transform((val) => val.toLowerCase()))
  .pipe(z.transform((val) => val.trim()))
  .pipe(z.string().min(3));
```

**`.pipe()` benefits**:
- Clear transformation pipeline
- Better type inference
- Potential performance optimization

### Avoid Over-Validation

**❌ Don't duplicate database constraints:**

```typescript
// ❌ Redundant - DB already enforces unique
const EmailSchema = z.string()
  .email()
  .refine(async (email) => {
    return !(await checkEmailExists(email));
  });
```

**✅ Trust database constraints where appropriate:**

```typescript
// ✅ Let database unique constraint handle it
const EmailSchema = z.string().email();

// Handle unique violation in error handling layer
```

---

## Common Mistakes to Avoid

### ❌ Mistake 1: Not Using `.coerce` for Dates

```typescript
// ❌ Will fail - Supabase returns ISO strings
createdAt: z.date()

// ✅ Correct - Converts string to Date
createdAt: z.coerce.date()
```

### ❌ Mistake 2: Missing Error Messages

```typescript
// ❌ Generic error message
z.string().min(2)

// ✅ Descriptive Spanish message
z.string().min(2, "Debe tener al menos 2 caracteres")
```

### ❌ Mistake 3: Business Logic in Entities

```typescript
// ❌ Wrong - Business logic in entities
export const validateAge = (age: number): boolean => {
  return age >= 18;
};

// ✅ Correct - Only schema
export const AgeSchema = z.number().int().min(18, "Debe ser mayor de 18 años");
```

### ❌ Mistake 4: Not Making Update Schemas Partial

```typescript
// ❌ Wrong - All fields required
export const EntityUpdateSchema = EntitySchema.omit({
  id: true,
  createdAt: true,
});

// ✅ Correct - Partial update
export const EntityUpdateSchema = EntitySchema
  .omit({ id: true, createdAt: true })
  .partial();
```

### ❌ Mistake 5: Forgetting Type Inference

```typescript
// ❌ Manual type definition (will diverge)
export type Entity = {
  id: string;
  name: string;
  // ...
};

// ✅ Inferred from schema (always in sync)
export type Entity = z.infer<typeof EntitySchema>;
```

---

## Template Checklist

When creating entities.ts, verify:

- [ ] File header JSDoc comment
- [ ] Only imports Zod (no other dependencies)
- [ ] Main entity schema with full validation
- [ ] Create schema (omits auto-generated fields)
- [ ] Update schema (partial, omits immutable fields)
- [ ] Query schema (if list endpoint exists)
- [ ] All TypeScript types inferred with `z.infer`
- [ ] Error messages in Spanish
- [ ] Uses `.coerce.date()` for timestamps
- [ ] Includes `organizationId` for multi-tenant entities
- [ ] Includes `userId` for ownership tracking
- [ ] No business logic functions
- [ ] Compiles without errors

---

## References

**Zod official docs**: https://zod.dev
**Context7 Zod patterns**: `/colinhacks/zod`

**Latest patterns verified**: 2025-10-24

---

**Last Updated**: 2025-10-24
